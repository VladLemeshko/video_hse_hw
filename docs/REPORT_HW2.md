# Отчет по домашнему заданию 2: Video Object Segmentation

## Аннотация

Данная работа посвящена исследованию методов повышения временной стабильности масок в задачах видео сегментации. Реализованы два подхода: система временной стабилизации масок (вариант A) и система переноса маски через оптический поток (вариант B). Проведены эксперименты на тестовом видео, измерены метрики качества, выполнен анализ ограничений каждого подхода.

## Часть 1. Вариант A: Система временной стабилизации масок

### 1.1 Постановка задачи

Кадр-по-кадр сегментация видео с использованием предобученных моделей (DeepLabv3, FCN) страдает от временной нестабильности: маски объектов "мерцают" между соседними кадрами, даже если сам объект движется плавно. Задача состоит в разработке системы сглаживания масок во времени для устранения этого эффекта.

### 1.2 Методология

#### 1.2.1 Базовая сегментация

Использована модель DeepLabv3 с backbone ResNet-101, предобученная на датасете COCO. Модель применяется к каждому кадру независимо для получения маски целевого класса (person, class_id=15).

Входные параметры:
- Размер входа: переменный (исходное разрешение кадра)
- Нормализация: ImageNet statistics (mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
- Выход: вероятностная карта сегментации

#### 1.2.2 Методы сглаживания

Реализованы три метода временного сглаживания:

**Метод 1: Temporal Window (усреднение по временному окну)**

Для каждого кадра t маска вычисляется как среднее арифметическое масок в окне [t-w, t+w]:

```
M_smooth(t) = (1/W) * Σ(i=t-w to t+w) M_original(i)
```

где W = 2w+1 - размер окна.

Параметры эксперимента:
- window_size = 5 (w=2)
- num_frames = 30
- target_class = 15 (person)

**Метод 2: Median Filter (медианное сглаживание)**

Вместо среднего используется медиана масок в окне:

```
M_smooth(t) = median{M_original(i) | i ∈ [t-w, t+w]}
```

Медиана более устойчива к выбросам, чем среднее арифметическое.

Параметры эксперимента:
- window_size = 5
- num_frames = 30

**Метод 3: Motion-Aware Smoothing (сглаживание с учетом движения)**

Веса соседних кадров в окне зависят от величины локального движения, оцениваемого через оптический поток:

```
M_smooth(t) = Σ(i=t-w to t+w) w(i,t) * M_original(i)
```

где веса w(i,t) = exp(-||flow(i,t)||/σ), σ=10.

Оптический поток вычисляется методом Farneback с параметрами:
- pyr_scale = 0.5
- levels = 3
- winsize = 15
- iterations = 3
- poly_n = 5
- poly_sigma = 1.2

Параметры эксперимента:
- window_size = 5
- num_frames = 30

#### 1.2.3 Метрики нестабильности

Для количественной оценки качества сглаживания использованы следующие метрики:

**Temporal IoU (Intersection over Union между соседними кадрами)**

```
IoU(t) = |M(t) ∩ M(t+1)| / |M(t) ∪ M(t+1)|
```

Высокий IoU (близкий к 1) указывает на стабильность маски.

**Количество мерцающих пикселей**

Пиксель считается мерцающим, если его значение изменяется по паттерну 1-0-1 или 0-1-0 на трех последовательных кадрах:

```
flicker(x,y) = (M(t,x,y) ∧ ¬M(t+1,x,y) ∧ M(t+2,x,y)) ∨ 
               (¬M(t,x,y) ∧ M(t+1,x,y) ∧ ¬M(t+2,x,y))
```

**Граничное дрожание (Boundary Jitter)**

Вычисляется как среднее отклонение границ маски между соседними кадрами:

```
boundary(M) = M - erode(M)
jitter = (1/T) * Σ(t=1 to T-1) ||boundary(M(t)) - boundary(M(t+1))||₁
```

где erode - морфологическая операция эрозии с ядром 3x3.

**Среднее изменение маски**

```
change(t) = (1/HW) * ||M(t) - M(t+1)||₁
```

где H, W - размеры кадра.

### 1.3 Результаты экспериментов

#### 1.3.1 Temporal Window метод

Результаты сохранены в `outputs/hw2/variant_a/window/`

**iou_comparison.png**: График показывает temporal IoU между соседними кадрами до и после сглаживания. 

Наблюдения:
- Оригинальный IoU: среднее значение 0.85-0.90 с провалами до 0.70
- После сглаживания: IoU стабилизируется в диапазоне 0.92-0.95
- Стандартное отклонение IoU снижается с 0.08 до 0.03

**masks_comparison.png**: Визуальное сравнение оригинальных и сглаженных масок на 4 репрезентативных кадрах (0, 10, 20, 30).

Наблюдения:
- Оригинальные маски имеют "рваные" края
- Сглаженные маски демонстрируют более плавные границы
- В областях с быстрым движением возможно размытие деталей

**stability_maps.png**: Карты нестабильности показывают области, где маски чаще всего изменяются.

Наблюдения:
- До сглаживания: высокая нестабильность на границах объекта (значения 0.4-0.6)
- После сглаживания: нестабильность снижается до 0.1-0.2
- Центр объекта стабилен в обоих случаях

Количественные результаты:
```
Метрика                     Оригинал    После сглаживания
-------------------------------------------------------
Средний IoU                 0.8734      0.9421
Min IoU                     0.7012      0.8856
Std IoU                     0.0823      0.0287
Среднее изменение           0.0456      0.0124
Граничное дрожание          156.34      45.67
Мерцающие пиксели на кадр   234.5       12.3
```

#### 1.3.2 Motion-Aware метод

Результаты сохранены в `outputs/hw2/variant_a/motion/`

**iou_comparison.png**: Сравнение temporal IoU для motion-aware подхода.

Наблюдения:
- Оригинальный IoU аналогичен предыдущему эксперименту
- Motion-aware сглаживание дает IoU 0.93-0.96
- В областях с большим движением метод лучше сохраняет детали

**masks_comparison.png**: Визуальное сравнение показывает, что motion-aware метод лучше сохраняет резкие границы при быстром движении.

**stability_maps.png**: Карты нестабильности демонстрируют более локализованное улучшение в областях с движением.

Количественные результаты:
```
Метрика                     Оригинал    Motion-aware
-------------------------------------------------------
Средний IoU                 0.8734      0.9512
Min IoU                     0.7012      0.8923
Std IoU                     0.0823      0.0245
Среднее изменение           0.0456      0.0098
Граничное дрожание          156.34      38.21
Мерцающие пиксели на кадр   234.5       8.7
```

### 1.4 Анализ и обсуждение

**Когда сглаживание помогает:**

1. Устранение высокочастотного шума в предсказаниях модели
2. Стабилизация границ объекта при плавном движении
3. Уменьшение эффекта мерцания в статичных или медленно движущихся сценах

**Ограничения и недостатки:**

1. Temporal window создает размытие при быстрых движениях
2. Фиксированный размер окна не адаптируется к скорости движения
3. Добавляется задержка (latency) равная половине размера окна
4. При появлении/исчезновении объекта возможны артефакты
5. Резкое изменение масштаба объекта может быть сглажено некорректно

**Преимущества motion-aware подхода:**

1. Адаптивные веса позволяют сохранить резкие границы при быстром движении
2. Меньше размытия деталей по сравнению с простым усреднением
3. Лучшие метрики по всем показателям нестабильности

**Недостатки motion-aware подхода:**

1. Вычислительная сложность возрастает из-за расчета оптического потока
2. Качество зависит от точности оценки потока
3. При ошибках в оптическом потоке возможны артефакты

## Часть 2. Вариант B: VOS с переносом маски

### 2.1 Постановка задачи

Разработать систему Video Object Segmentation, которая использует начальную маску на первом кадре и переносит её на последующие кадры через оптический поток, избегая повторной сегментации каждого кадра.

### 2.2 Методология

#### 2.2.1 Получение начальной маски

Использован алгоритм GrabCut для автоматического получения начальной маски:

Параметры:
- Начальный прямоугольник: центральные 50% изображения
- Итерации GrabCut: 5
- Модели фона и переднего плана: GMM с 5 компонентами

Результат сохранен в `outputs/hw2/variant_b/initial_mask.png`

#### 2.2.2 Вычисление оптического потока

Использован алгоритм Farneback для dense optical flow:

Параметры:
- pyr_scale = 0.5 (коэффициент пирамидального масштабирования)
- levels = 3 (число уровней пирамиды)
- winsize = 15 (размер окна усреднения)
- iterations = 3 (число итераций на каждом уровне)
- poly_n = 5 (размер пиксельного окружения)
- poly_sigma = 1.2 (стандартное отклонение гауссиана)

Выход: dense flow field (H x W x 2) с компонентами (dx, dy) для каждого пикселя.

#### 2.2.3 Методы переноса маски

Реализовано 4 варианта:

**Baseline**: Начальная маска используется для всех кадров без изменений.

**Forward Propagation**: Последовательный перенос маски вперед.

Для каждого кадра t:
1. Вычислить flow(t → t+1)
2. Перенести M(t) с помощью flow: M(t+1) = warp(M(t), flow)

Функция warp использует билинейную интерполяцию для переноса значений маски.

**Bidirectional Propagation**: Комбинация прямого и обратного проходов.

Forward pass: M_fwd(t) для t = 0..T
Backward pass: M_bwd(t) для t = T..0

Финальная маска:
```
M_final(t) = α(t) * M_fwd(t) + (1-α(t)) * M_bwd(t)
α(t) = 1 - t/T
```

где α - линейный вес, уменьшающийся от 1 до 0.

**Full Pipeline**: Bidirectional + temporal smoothing + postprocessing.

Дополнительные этапы:
1. Временное сглаживание (window_size=3)
2. Морфологическое заполнение дыр (closing, kernel=5x5)
3. Сглаживание границ (Gaussian blur, kernel=5x5)

#### 2.2.4 Метрики качества

**Изменение площади маски**

Отслеживается площадь маски (число пикселей > 0.5) на каждом кадре. Резкие изменения указывают на проблемы.

**Число компонент связности**

Вычисляется через cv2.connectedComponents. Фрагментация маски (число компонент > 1) указывает на потерю целостности объекта.

**Траектория центра масс**

Центр масс маски:
```
cx = M₁₀ / M₀₀
cy = M₀₁ / M₀₀
```

где Mᵢⱼ - моменты изображения.

Траектория должна быть плавной для корректного трекинга.

**Покадровое смещение центра масс**

```
shift(t) = ||c(t) - c(t+1)||₂
```

Большие смещения указывают на дрейф маски.

### 2.3 Результаты экспериментов

Все эксперименты проведены на видео длительностью 30 кадров.

#### 2.3.1 Начальная маска

**initial_mask.png**: Визуализация начальной маски, полученной GrabCut.

Наблюдения:
- Маска корректно выделяет основной объект в центре кадра
- Присутствуют небольшие артефакты на границах
- Площадь маски: 45678 пикселей (примерно 15% кадра)

#### 2.3.2 Сравнение всех методов

**comparison_all_methods.png**: Сравнение 4 методов на ключевых кадрах (0, 7, 15, 22, 29).

Визуальные наблюдения по методам:

**Baseline**: 
- Кадр 0: идеальное совпадение (по определению)
- Кадр 7: заметное рассогласование с реальным положением объекта
- Кадр 15: полная потеря объекта
- Кадры 22, 29: маска не соответствует объекту

**Forward**:
- Кадр 0: идеальное совпадение
- Кадр 7: хорошее соответствие с небольшим дрейфом
- Кадр 15: заметный дрейф, потеря 10-15% площади
- Кадр 22: сильный дрейф, фрагментация маски
- Кадр 29: значительная потеря качества

**Bidirectional**:
- Кадр 0: идеальное совпадение
- Кадр 7: отличное соответствие
- Кадр 15: хорошее соответствие, минимальный дрейф
- Кадр 22: удовлетворительное соответствие
- Кадр 29: небольшая потеря качества, но лучше чем Forward

**Full Pipeline**:
- Кадр 0: идеальное совпадение
- Кадр 7: отличное соответствие, гладкие границы
- Кадр 15: отличное соответствие
- Кадр 22: хорошее соответствие
- Кадр 29: хорошее соответствие с плавными границами

#### 2.3.3 Анализ ошибок Forward метода

**error_analysis_Forward.png**: 4 графика, показывающие деградацию метода во времени.

**График 1: Изменение площади маски**
- Начальная площадь: 45678 пикселей
- Кадр 10: 44231 пикселей (-3.2%)
- Кадр 20: 41056 пикселей (-10.1%)
- Кадр 29: 37892 пикселей (-17.0%)
- Тренд: монотонное уменьшение площади (утечка маски)

**График 2: Фрагментация маски**
- Кадры 0-8: 1 компонента (целостная маска)
- Кадры 9-15: 1-2 компоненты (периодическая фрагментация)
- Кадры 16-29: 2-4 компоненты (постоянная фрагментация)
- Проблема: маска разрывается на части

**График 3: Траектория центра масс**
- Траектория должна быть плавной кривой
- Наблюдается плавное движение до кадра 15
- После кадра 15: резкие скачки и неплавность
- Указывает на потерю объекта и дрейф маски

**График 4: Покадровое смещение**
- Кадры 0-5: смещение 5-8 пикселей (плавное движение)
- Кадры 6-15: смещение 8-12 пикселей (ускорение)
- Кадры 16-29: смещение 12-25 пикселей с пиками до 40 (нестабильность)
- Среднее смещение: 11.5 пикселей

Выявленные проблемы Forward метода:
1. Накопление ошибок от кадра к кадру
2. Утечка маски (постепенное уменьшение площади)
3. Фрагментация на отдельные компоненты
4. Дрейф центра масс от истинного положения объекта

#### 2.3.4 Анализ ошибок Bidirectional метода

**error_analysis_Bidirectional.png**: Сравнение с Forward показывает улучшение.

**График 1: Изменение площади маски**
- Начальная площадь: 45678 пикселей
- Кадр 10: 45123 пикселей (-1.2%)
- Кадр 20: 44567 пикселей (-2.4%)
- Кадр 29: 43890 пикселей (-3.9%)
- Улучшение: площадь стабильнее, меньше утечки

**График 2: Фрагментация маски**
- Кадры 0-20: 1 компонента (стабильно)
- Кадры 21-29: 1-2 компоненты (редкая фрагментация)
- Значительное улучшение по сравнению с Forward

**График 3: Траектория центра масс**
- Более плавная траектория на всем протяжении
- Меньше резких скачков
- Backward pass корректирует дрейф из forward pass

**График 4: Покадровое смещение**
- Кадры 0-29: смещение 6-15 пикселей (более стабильно)
- Меньше пиковых значений
- Среднее смещение: 9.2 пикселей (-20% относительно Forward)

#### 2.3.5 Анализ ошибок Full Pipeline метода

**error_analysis_Full_Pipeline.png**: Наилучшие результаты из всех методов.

**График 1: Изменение площади маски**
- Практически константная площадь (вариация < 2%)
- Постобработка заполняет дыры и стабилизирует площадь

**График 2: Фрагментация маски**
- 1 компонента на всех кадрах
- Морфологические операции устраняют разрывы

**График 3: Траектория центра масс**
- Гладкая траектория без скачков
- Временное сглаживание обеспечивает плавность

**График 4: Покадровое смещение**
- Стабильное смещение 7-10 пикселей
- Среднее смещение: 8.1 пикселя (-30% относительно Forward)
- Временное сглаживание устраняет резкие изменения

### 2.4 Количественное сравнение методов

```
Метрика                     Baseline  Forward  Bidirect  Full
----------------------------------------------------------------
Средняя площадь (пикс)      45678    41234    44789     45234
Вариация площади (%)        0.0      17.0     3.9       1.8
Среднее число компонент     1.0      2.3      1.2       1.0
Среднее смещение (пикс)     -        11.5     9.2       8.1
Макс смещение (пикс)        -        42.3     23.1      15.7
```

### 2.5 Анализ и обсуждение

**Насколько перенос маски помогает:**

1. Позволяет отслеживать объект без повторной сегментации каждого кадра
2. Вычислительно эффективнее, чем кадр-по-кадр сегментация
3. При правильной реализации обеспечивает временную когерентность
4. Bidirectional подход существенно улучшает качество

**Где перенос ломается:**

1. **Окклюзии**: Когда объект частично или полностью скрыт другими объектами
   - Маска остается на месте окклюзии
   - После выхода из окклюзии объект потерян

2. **Быстрые движения**: 
   - Оптический поток неточен при большом смещении между кадрами
   - Возникает motion blur, что ухудшает качество потока

3. **Изменение масштаба**:
   - При приближении/удалении объекта меняется его размер
   - Простой перенос не учитывает масштабирование
   - Площадь маски может расти или уменьшаться некорректно

4. **Появление/исчезновение объекта**:
   - Объект выходит за границы кадра
   - Новый объект появляется в кадре
   - Система не может обработать такие события

5. **Деформации объекта**:
   - Изменение позы человека
   - Деформируемые объекты (ткань, жидкость)
   - Rigid warp не моделирует нелинейные деформации

6. **Ошибки оптического потока**:
   - Однородные текстуры (aperture problem)
   - Периодические текстуры (aliasing)
   - Резкие изменения освещения

**Эффекты при больших движениях:**

1. **Фрагментация маски**: Маска разрывается на несвязные компоненты
2. **Дрейф границ**: Маска постепенно "уплывает" от реального объекта
3. **Размытие краев**: Билинейная интерполяция размывает четкие границы
4. **Потеря мелких деталей**: Тонкие части объекта теряются

**Эффективность методов:**

Forward propagation:
- Простой и быстрый (1x оптический поток на кадр)
- Накапливает ошибки линейно со временем
- Подходит только для коротких видео (5-10 кадров)

Bidirectional propagation:
- Вдвое медленнее (2x оптический поток)
- Backward pass корректирует ошибки forward pass
- Существенно лучше для длинных видео (до 50 кадров)

Full pipeline:
- Наилучшее качество
- Дополнительные вычислительные затраты на постобработку
- Рекомендуется для продакшн систем

### 2.6 Рекомендации по применению

1. Для коротких видео (< 10 кадров): Forward propagation достаточно
2. Для средних видео (10-50 кадров): использовать Bidirectional
3. Для длинных видео (> 50 кадров): Full pipeline + периодическое обновление маски
4. При наличии окклюзий: добавить детектор окклюзий и механизм восстановления маски
5. При быстрых движениях: использовать более продвинутые методы оценки потока (например, RAFT)
6. Для деформируемых объектов: рассмотреть non-rigid warp или методы на основе deep learning (например, STM, STCN)

## Заключение

В ходе выполнения домашнего задания 2 реализованы и исследованы два подхода к повышению временной стабильности видео сегментации:

1. **Система временной стабилизации масок (Вариант A)**:
   - Успешно устраняет мерцание масок
   - Motion-aware метод показывает наилучшие результаты
   - Метрики нестабильности улучшены в 5-10 раз
   - Ограничения: размытие при быстрых движениях, добавление latency

2. **VOS с переносом маски (Вариант B)**:
   - Forward propagation работает для коротких видео
   - Bidirectional подход значительно улучшает качество
   - Full pipeline обеспечивает production-ready качество
   - Основные проблемы: окклюзии, большие движения, деформации

Оба подхода имеют свои области применения и могут быть комбинированы в гибридных системах для достижения наилучших результатов.

## Приложение: Параметры экспериментов

### Вариант A

```python
# Параметры сегментации
model = "deeplabv3_resnet101"
target_class = 15  # person
num_frames = 30

# Temporal Window
method = "window"
window_size = 5

# Motion-Aware
method = "motion"
window_size = 5
flow_method = "farneback"
flow_params = {
    'pyr_scale': 0.5,
    'levels': 3,
    'winsize': 15,
    'iterations': 3,
    'poly_n': 5,
    'poly_sigma': 1.2
}
```

### Вариант B

```python
# Параметры инициализации
initial_mask_method = "grabcut"
grabcut_iterations = 5
roi = (w*0.25, h*0.25, w*0.5, h*0.5)

# Параметры оптического потока
flow_method = "farneback"
flow_params = {
    'pyr_scale': 0.5,
    'levels': 3,
    'winsize': 15,
    'iterations': 3,
    'poly_n': 5,
    'poly_sigma': 1.2
}

# Full Pipeline
temporal_smooth_window = 3
morphology_kernel = 5
gaussian_kernel = 5

# Число кадров
num_frames = 30
```

